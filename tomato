#!/usr/bin/env python3

import sys
import yaml
from copy import deepcopy
from itertools import product

class Choice:
    def __init__(self, description):
        self.name = ''
        self.value = ''
        self.choices = []
        
        if isinstance(description, dict):
            children = list(description.keys())
            self.name = children[0]
            
            if description[self.name] is not None:
                self.value = str(description[self.name])
            else:
                self.value = self.name
                
            if 'choices' in description:
                self.choices = [Choice(choice) for choice in description['choices']]
        else:
            self.name = str(description)
            self.value = str(description)
                    
    def __str__(self):
        return f'{self.name}: {self.value}'
    
    def __repr__(self):
        return str(self)
    
    def get_choice_names(self, current_path=''):
        if current_path == '':
            current_path = self.name
        else:
            current_path = f'{current_path}::{self.name}'
        if self.choices:
            result = []
            for choice in self.choices:
                if len(choice.choices) == 0:
                    result.append(f'{current_path}::{choice.name}')
                else:
                    result.extend(choice.get_choice_names(current_path))
            return result
        else:
            return []

class OutputParameter:
    def __init__(self, description):
        self.name = description['output parameter']
        self.default_value = description['default value']
        self.parameters = []
        
    def __str__(self):
        return f'{self.name}: {self.default_value}'
    
    def __repr__(self):
        return str(self)
    
    def get_choice_names(self):
        return ['output parameter']
        
        
class Parameter:
    def __init__(self, description, global_params) -> None:
        self.name = ''
        self.choices = []
        self.parameters = []
        
        if isinstance(description, dict):
            self.name = description['parameter']
            if 'parameters' in description and 'choices' in description:
                print(f'Error: {self.name} has both parameters and choices')
                sys.exit(1)
            if 'parameters' in description:
                for parameter in description['parameters']:
                    if 'linked parameter' in parameter:
                        linked_to = parameter['linked to']
                        name = parameter['linked parameter']
                        copy = deepcopy(global_params[linked_to])
                        copy.name = name
                        self.parameters.append(copy)
                    else:
                        self.parameters.append(Parameter(parameter, global_params))
            if 'choices' in description:
                self.choices = [Choice(choice) for choice in description['choices']]
                
    def __str__(self):
        result = f'{self.name}'
        if self.parameters:
            result += '('
            for parameter in self.parameters:
                result += f'{parameter}, '
            result = result[:-2] + ')'
        return result
    
    def __repr__(self):
        return str(self)

    def get_parameter_names(self, current_path=''):
        result = []
        if current_path == '':
            current_path = self.name
        else:
            current_path = f'{current_path}::{self.name}'
        for parameter in self.parameters:
            if parameter.parameters:
                result.extend(parameter.get_parameter_names(current_path))
            else:
                result.append(f'{current_path}::{parameter.name}')
        return result
    
    def get_choice_names(self, current_path=''):
        if self.parameters:
            return [parameter.get_choice_names() for parameter in self.parameters]
        elif self.choices:
            result = []
            for choice in self.choices:
                if len(choice.choices) == 0:
                    result.append(choice.name)
                else:
                    result.extend(choice.get_choice_names())
            return result
        else:
            return []
        

class Function:
    def __init__(self, global_params, description):
        self.parameters = []
        for parameter in description['parameters']:
            if 'output parameter' in parameter:
                self.parameters.append(OutputParameter(parameter))
            elif 'linked parameter' in parameter:
                linked_to = parameter['linked to']
                name = parameter['linked parameter']
                copy = deepcopy(global_params[linked_to])
                copy.name = name
                self.parameters.append(copy)
            else:
                self.parameters.append(Parameter(parameter, global_params))
        
    def __str__(self):
        return f'{self.name}({[parameter.name for parameter in self.parameters]})'
    
    def get_parameter_names(self):
        result = []
        for parameter in self.parameters:
            if parameter.parameters:
                result.extend(parameter.get_parameter_names())
            else:
                result.append(parameter.name)
        return result
    
    def get_leaf_choices(self):
        result = [parameter.get_choice_names() for parameter in self.parameters]
        def flatten_array(array):
            result = []
            for item in array:
                if isinstance(item, list):
                    l = [sub_item for sub_item in item if not isinstance(sub_item, list)]
                    result.append(l)
                    result.extend(flatten_array([sub_item for sub_item in item if isinstance(sub_item, list)]))
                else:
                    result.append(item)
            result = [item for item in result if item != []]
            return result
        return flatten_array(result)
    
    def get_generator_input(self):
        return self.get_parameter_names(), self.get_leaf_choices()

class Model:
    def __init__(self, file):
        try:
            with open(file, 'r') as f:
                model = yaml.safe_load(f.read())
                global_params = {parameter['parameter']: Parameter(parameter, None) for parameter in model['global parameters']}
                if 'functions' in model:
                    self.functions = [Function(global_params, function) for function in model['functions']]
                else:
                    self.functions = [Function(global_params, model['function'])]
        except OSError as e:
            print(f'Error: unable to open file {file}: {e}')
            sys.exit(1)

class CartesianGenerator:
    def __init__(self, parameter_names, choices):
        self.parameter_names = parameter_names
        self.choices = choices
        
        self.cartesian_product = list(product(*choices))
        
    def export_csv(self, file):
        if file is None:
            for tuple in self.cartesian_product:
                print(','.join(tuple))
        else:
            with open(file, 'w') as f:
                f.write(','.join(self.parameter_names) + '\n')
                for tuple in self.cartesian_product:
                    f.write(','.join(tuple) + '\n')
        
    
if __name__ == '__main__':
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print('Usage: python ecr_feed <input_file> [<output_file>]')
        sys.exit(1)
        
    input_file = sys.argv[1]
    if len(sys.argv) == 3:
        output_file = sys.argv[2]
    else:
        output_file = None
    
    model = Model(input_file)
    function = model.functions[0]
    print(function.get_generator_input())

    gen = CartesianGenerator(*function.get_generator_input())  
    gen.export_csv(output_file)  
    
