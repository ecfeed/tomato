#!/usr/bin/env python3

import sys
import yaml
from copy import deepcopy, copy
from itertools import combinations, product
from collections import Counter
import random

class Choice:
    def __init__(self, description):
        self.name = ''
        self.value = ''
        self.choices = []
        
        if isinstance(description, dict):
            children = list(description.keys())
            self.name = children[0]
            
            if description[self.name] is not None:
                self.value = str(description[self.name])
            else:
                self.value = self.name
                
            if 'choices' in description:
                self.choices = [Choice(choice) for choice in description['choices']]
        else:
            self.name = str(description)
            self.value = str(description)
                    
    def __str__(self):
        return f'{self.name}: {self.value}'
    
    def __repr__(self):
        return str(self)
    
    def get_choice_names(self, current_path=''):
        if current_path == '':
            current_path = self.name
        else:
            current_path = f'{current_path}::{self.name}'
        if self.choices:
            result = []
            for choice in self.choices:
                if len(choice.choices) == 0:
                    result.append(f'{current_path}::{choice.name}')
                else:
                    result.extend(choice.get_choice_names(current_path))
            return result
        else:
            return []

class OutputParameter:
    def __init__(self, description):
        self.name = description['output parameter']
        self.default_value = description['default value']
        self.parameters = []
        
    def __str__(self):
        return f'{self.name}: {self.default_value}'
    
    def __repr__(self):
        return str(self)
    
    def get_choice_names(self):
        return [str(self.default_value)]
        
class Parameter:
    def __init__(self, description, global_params) -> None:
        self.name = ''
        self.choices = []
        self.parameters = []
        
        if isinstance(description, dict):
            self.name = description['parameter']
            if 'parameters' in description and 'choices' in description:
                print(f'Error: {self.name} has both parameters and choices')
                sys.exit(1)
            if 'parameters' in description:
                for parameter in description['parameters']:
                    if 'linked parameter' in parameter:
                        linked_to = parameter['linked to']
                        name = parameter['linked parameter']
                        copy = deepcopy(global_params[linked_to])
                        copy.name = name
                        self.parameters.append(copy)
                    else:
                        self.parameters.append(Parameter(parameter, global_params))
            if 'choices' in description:
                self.choices = [Choice(choice) for choice in description['choices']]
                
    def __str__(self):
        result = f'{self.name}'
        if self.parameters:
            result += '('
            for parameter in self.parameters:
                result += f'{parameter}, '
            result = result[:-2] + ')'
        return result
    
    def __repr__(self):
        return str(self)

    def get_parameter_names(self, current_path=''):
        result = []
        if current_path == '':
            current_path = self.name
        else:
            current_path = f'{current_path}::{self.name}'
        for parameter in self.parameters:
            if parameter.parameters:
                result.extend(parameter.get_parameter_names(current_path))
            else:
                result.append(f'{current_path}::{parameter.name}')
        return result
    
    def get_choice_names(self, current_path=''):
        if self.parameters:
            return [parameter.get_choice_names() for parameter in self.parameters]
        elif self.choices:
            result = []
            for choice in self.choices:
                if len(choice.choices) == 0:
                    result.append(choice.name)
                else:
                    result.extend(choice.get_choice_names())
            return result
        else:
            return []

class Function:
    def __init__(self, global_params, description):
        self.name = description['function']
        self.parameters = []
        for parameter in description['parameters']:
            if 'output parameter' in parameter:
                self.parameters.append(OutputParameter(parameter))
            elif 'linked parameter' in parameter:
                linked_to = parameter['linked to']
                name = parameter['linked parameter']
                copy = deepcopy(global_params[linked_to])
                copy.name = name
                self.parameters.append(copy)
            else:
                self.parameters.append(Parameter(parameter, global_params))
        
    def __str__(self):
        return f'{self.name}({[parameter.name for parameter in self.parameters]})'
    
    def get_parameter_names(self):
        result = []
        for parameter in self.parameters:
            if parameter.parameters:
                result.extend(parameter.get_parameter_names())
            else:
                result.append(parameter.name)
        return result
    
    def get_leaf_choices(self):
        result = [parameter.get_choice_names() for parameter in self.parameters]
        def flatten_array(array):
            result = []
            for item in array:
                if isinstance(item, list):
                    l = [sub_item for sub_item in item if not isinstance(sub_item, list)]
                    result.append(l)
                    result.extend(flatten_array([sub_item for sub_item in item if isinstance(sub_item, list)]))
                else:
                    result.append(item)
            result = [item for item in result if item != []]
            return result
        return flatten_array(result)
    
    def get_generator_input(self):
        return self.get_parameter_names(), self.get_leaf_choices()

class Model:
    def __init__(self, file):
        try:
            with open(file, 'r') as f:
                model = yaml.safe_load(f.read())
                global_params = {}
                if 'global parameters' in model:
                    for parameter in model['global parameters']:
                        global_params[parameter['parameter']] = Parameter(parameter, global_params)
                        
                if 'functions' in model:
                    self.functions = {f.name : f for f in [Function(global_params, function) for function in model['functions']]}
                elif 'function' in model:
                    self.functions = {function.name : function for function in [Function(global_params, model['function'])]}
                else:
                    print('Error: no function specified')
                    sys.exit(1)
        except OSError as e:
            print(f'Error: unable to open file {file}: {e}')
            sys.exit(1)

def print_csv_line(header, line, output=sys.stderr):
    cleaned_line = [str(element) if element is not None else ' ' for element in line]
    # if header is not None:
    #     output.write('(' + header + ') ')
    output.write(','.join(cleaned_line) + '\n')
    # pass
    
def clean_line(output=sys.stderr):
    output.write('\033[1A')
    output.write('\033[K')
    # output.write('\n')
    # pass


def nwise(input_list, n, solver, assigner):
    if n > len(input_list):
        raise ValueError("n cannot be greater than the length of the input list")

    def tuples_covered(test_case, n):
        if n > len(test_case):
            raise ValueError("n cannot be greater than the size of the test case")

        indices = [i for i, _ in enumerate(test_case) if test_case[i] is not None]
        
        combinations_ = combinations(indices, n)
        def uncompress(indices):
            return tuple([test_case[i] if i in indices else None for i in range(len(test_case))])
        yield from [uncompress(test) for test in combinations_]
        
    def tuples(input_list, n):
        def tuple_template(n, input_size):
            if n > input_size:
                raise ValueError("n cannot be greater than m")

            for combination in combinations(range(input_size), n):
                template = [False] * input_size
                for index in combination:
                    template[index] = True
                yield template

        def tuples_from_template(input_list, template):
            len_input_list = len(input_list)
            if len_input_list != len(template):
                raise ValueError("Input list and template must have the same length")

            selected_indices = [i for i, is_selected in enumerate(template) if is_selected]

            for combination in product(*[input_list[i] for i in selected_indices]):
                result = [None] * len_input_list
                for i, index in enumerate(selected_indices):
                    result[index] = combination[i]
                yield tuple(result) # tuple is hashable, list is not
                
        if n > len(input_list):
            raise ValueError("n cannot be greater than the length of the input list")

        for template in tuple_template(n, len(input_list)):
            yield from tuples_from_template(input_list, template)

    tuples_to_cover = {t for t in tuples(input_list, n) if solver(t)}

    def tuple_score(candidate):
        if not solver(candidate):
            return -1
        else:
            covered_tuples = tuples_covered(candidate, n)
            score = len(tuples_to_cover.intersection(covered_tuples))
            return score

    while len(tuples_to_cover) > 0:
        # for tuple_to_cover in tuples_to_cover:
        tuple_to_cover = random.choice(list(tuples_to_cover))
        indices = [i for i, x in enumerate(tuple_to_cover) if x is None]
        random.shuffle(indices)
        
        constructed_test_case = copy(tuple_to_cover)
        print_csv_line(str(len(tuples_to_cover)) + ' tuples to go', constructed_test_case)
        for i in indices:
            best_candidate, best_score = None, -1
            choices = input_list[i]
            random.shuffle(choices)
            for value in choices:
                candidate = list(copy(constructed_test_case))
                candidate[i] = value
                clean_line()
                print_csv_line(str(len(tuples_to_cover)) + ' tuples to go', candidate)
                score = tuple_score(candidate)                    
                if score > best_score:
                    best_candidate = candidate
                    best_score = tuple_score(candidate)
                    
            constructed_test_case = best_candidate
            for t in tuples_covered(constructed_test_case, n):
                tuples_to_cover.discard(t) 
        assigner(constructed_test_case)
        clean_line()
        yield constructed_test_case

if __name__ == '__main__':
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print('Usage: python3 tomato <input_file> [<\'function name\'>]')
        sys.exit(1)
        
    input_file = sys.argv[1]
    
    function_name = None
    if len(sys.argv) == 3:
        function_name = sys.argv[2]
    
    model = Model(input_file)
    if function_name is None:
        function = list(model.functions.values())[0]
    else:
        function = model.functions[function_name]
    
    params, choices = function.get_generator_input()

    print(','.join(params))
    for test in nwise(choices, 2, lambda x: True, lambda x: None):       
        print(','.join(test))
    
    
