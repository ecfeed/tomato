#!/usr/bin/env python3

import sys
import yaml
from copy import deepcopy, copy
from itertools import combinations, product
from collections import Counter
import random
from model import Model
from constraint_solver import TomatoSolver

def print_csv_line(header, line, output=sys.stderr):
    cleaned_line = [str(element) if element is not None else ' ' for element in line]
    # if header is not None:
    #     output.write('(' + header + ') ')
    output.write(','.join(cleaned_line) + '\n')
    output.flush()
    # pass
    
def clean_line(output=sys.stderr):
    output.write('\033[1A')
    output.write('\033[K')
    output.flush()
    # output.write('\n')
    # pass


def nwise(input_list, n, solver, assigner):
    if n > len(input_list):
        raise ValueError("n cannot be greater than the length of the input list")

    def tuples_covered(test_case, n):
        if n > len(test_case):
            raise ValueError("n cannot be greater than the size of the test case")

        indices = [i for i, _ in enumerate(test_case) if test_case[i] is not None]
        
        combinations_ = combinations(indices, n)
        def uncompress(indices):
            return tuple([test_case[i] if i in indices else None for i in range(len(test_case))])
        yield from [uncompress(test) for test in combinations_]
        
    def tuples(input_list, n):
        def tuple_template(n, input_size):
            if n > input_size:
                raise ValueError("n cannot be greater than m")

            for combination in combinations(range(input_size), n):
                template = [False] * input_size
                for index in combination:
                    template[index] = True
                yield template

        def tuples_from_template(input_list, template):
            len_input_list = len(input_list)
            if len_input_list != len(template):
                raise ValueError("Input list and template must have the same length")

            selected_indices = [i for i, is_selected in enumerate(template) if is_selected]

            for combination in product(*[input_list[i] for i in selected_indices]):
                result = [None] * len_input_list
                for i, index in enumerate(selected_indices):
                    result[index] = combination[i]
                yield tuple(result) # tuple is hashable, list is not
                
        if n > len(input_list):
            raise ValueError("n cannot be greater than the length of the input list")

        for template in tuple_template(n, len(input_list)):
            yield from tuples_from_template(input_list, template)

    tuples_to_cover = {t for t in tuples(input_list, n) if solver.test(t)}

    def tuple_score(candidate):
        if not solver.test(candidate):
            return -1
        else:
            covered_tuples = tuples_covered(candidate, n)
            score = len(tuples_to_cover.intersection(covered_tuples))
            # print(f'Score of {candidate}: {score}')
            return score

    while len(tuples_to_cover) > 0:
        # for tuple_to_cover in tuples_to_cover:
        solver.new_test_case()
        tuple_to_cover = random.choice(list(tuples_to_cover))
        solver.tuple_selected(tuple_to_cover)
        indices = [i for i, x in enumerate(tuple_to_cover) if x is None]
        random.shuffle(indices)
        
        constructed_test_case = copy(tuple_to_cover)
        print_csv_line(str(len(tuples_to_cover)) + ' tuples to go', constructed_test_case)
        for i in indices:
            best_choice, best_candidate, best_score = None, None, -1
            choices = input_list[i]
            random.shuffle(choices)
            for choice in choices:
                candidate = list(copy(constructed_test_case))
                candidate[i] = choice
                clean_line()
                print_csv_line(str(len(tuples_to_cover)) + ' tuples to go', candidate)
                score = tuple_score(candidate)                    
                if score > best_score:
                    best_candidate = candidate
                    best_score = tuple_score(candidate)
                    best_choice = choice
                    
            constructed_test_case = best_candidate
            solver.choice_selected(i, best_choice)
            
            for t in tuples_covered(constructed_test_case, n):
                tuples_to_cover.discard(t) 
        test_case = assigner.adapt(constructed_test_case)
        clean_line()
        # print(f'Constructed test case: {constructed_test_case}')
        # yield constructed_test_case
        yield test_case

if __name__ == '__main__':
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print('Usage: python3 tomato <input_file> [<\'function name\'>]')
        sys.exit(1)
        
    input_file = sys.argv[1]
    
    function_name = None
    if len(sys.argv) == 3:
        function_name = sys.argv[2]
    
    model = Model(input_file)
    if function_name is None:
        function = list(model.functions.values())[0]
    else:
        function = model.functions[function_name]
    
    params, choices = function.get_generator_input()

    solver = TomatoSolver(function)
    print(','.join(params))
    for test in nwise(choices, 2, solver, solver):
        print(','.join(test))
    
    
