#!/usr/bin/env python3

import sys
import yaml
from copy import deepcopy
from itertools import combinations, product
from collections import Counter
import random

class Choice:
    def __init__(self, description):
        self.name = ''
        self.value = ''
        self.choices = []
        
        if isinstance(description, dict):
            children = list(description.keys())
            self.name = children[0]
            
            if description[self.name] is not None:
                self.value = str(description[self.name])
            else:
                self.value = self.name
                
            if 'choices' in description:
                self.choices = [Choice(choice) for choice in description['choices']]
        else:
            self.name = str(description)
            self.value = str(description)
                    
    def __str__(self):
        return f'{self.name}: {self.value}'
    
    def __repr__(self):
        return str(self)
    
    def get_choice_names(self, current_path=''):
        if current_path == '':
            current_path = self.name
        else:
            current_path = f'{current_path}::{self.name}'
        if self.choices:
            result = []
            for choice in self.choices:
                if len(choice.choices) == 0:
                    result.append(f'{current_path}::{choice.name}')
                else:
                    result.extend(choice.get_choice_names(current_path))
            return result
        else:
            return []

class OutputParameter:
    def __init__(self, description):
        self.name = description['output parameter']
        self.default_value = description['default value']
        self.parameters = []
        
    def __str__(self):
        return f'{self.name}: {self.default_value}'
    
    def __repr__(self):
        return str(self)
    
    def get_choice_names(self):
        return [str(self.default_value)]
        
        
class Parameter:
    def __init__(self, description, global_params) -> None:
        self.name = ''
        self.choices = []
        self.parameters = []
        
        if isinstance(description, dict):
            self.name = description['parameter']
            if 'parameters' in description and 'choices' in description:
                print(f'Error: {self.name} has both parameters and choices')
                sys.exit(1)
            if 'parameters' in description:
                for parameter in description['parameters']:
                    if 'linked parameter' in parameter:
                        linked_to = parameter['linked to']
                        name = parameter['linked parameter']
                        copy = deepcopy(global_params[linked_to])
                        copy.name = name
                        self.parameters.append(copy)
                    else:
                        self.parameters.append(Parameter(parameter, global_params))
            if 'choices' in description:
                self.choices = [Choice(choice) for choice in description['choices']]
                
    def __str__(self):
        result = f'{self.name}'
        if self.parameters:
            result += '('
            for parameter in self.parameters:
                result += f'{parameter}, '
            result = result[:-2] + ')'
        return result
    
    def __repr__(self):
        return str(self)

    def get_parameter_names(self, current_path=''):
        result = []
        if current_path == '':
            current_path = self.name
        else:
            current_path = f'{current_path}::{self.name}'
        for parameter in self.parameters:
            if parameter.parameters:
                result.extend(parameter.get_parameter_names(current_path))
            else:
                result.append(f'{current_path}::{parameter.name}')
        return result
    
    def get_choice_names(self, current_path=''):
        if self.parameters:
            return [parameter.get_choice_names() for parameter in self.parameters]
        elif self.choices:
            result = []
            for choice in self.choices:
                if len(choice.choices) == 0:
                    result.append(choice.name)
                else:
                    result.extend(choice.get_choice_names())
            return result
        else:
            return []
        

class Function:
    def __init__(self, global_params, description):
        self.parameters = []
        for parameter in description['parameters']:
            if 'output parameter' in parameter:
                self.parameters.append(OutputParameter(parameter))
            elif 'linked parameter' in parameter:
                linked_to = parameter['linked to']
                name = parameter['linked parameter']
                copy = deepcopy(global_params[linked_to])
                copy.name = name
                self.parameters.append(copy)
            else:
                self.parameters.append(Parameter(parameter, global_params))
        
    def __str__(self):
        return f'{self.name}({[parameter.name for parameter in self.parameters]})'
    
    def get_parameter_names(self):
        result = []
        for parameter in self.parameters:
            if parameter.parameters:
                result.extend(parameter.get_parameter_names())
            else:
                result.append(parameter.name)
        return result
    
    def get_leaf_choices(self):
        result = [parameter.get_choice_names() for parameter in self.parameters]
        def flatten_array(array):
            result = []
            for item in array:
                if isinstance(item, list):
                    l = [sub_item for sub_item in item if not isinstance(sub_item, list)]
                    result.append(l)
                    result.extend(flatten_array([sub_item for sub_item in item if isinstance(sub_item, list)]))
                else:
                    result.append(item)
            result = [item for item in result if item != []]
            return result
        return flatten_array(result)
    
    def get_generator_input(self):
        return self.get_parameter_names(), self.get_leaf_choices()

class Model:
    def __init__(self, file):
        try:
            with open(file, 'r') as f:
                model = yaml.safe_load(f.read())
                global_params = {parameter['parameter']: Parameter(parameter, None) for parameter in model['global parameters']}
                if 'functions' in model:
                    self.functions = [Function(global_params, function) for function in model['functions']]
                else:
                    self.functions = [Function(global_params, model['function'])]
        except OSError as e:
            print(f'Error: unable to open file {file}: {e}')
            sys.exit(1)

def nwise(input_list, n, solver, assigner):
    if n > len(input_list):
        raise ValueError("n cannot be greater than the length of the input list")

    def tuple_template(n, input_size):
        if n > input_size:
            raise ValueError("n cannot be greater than m")

        for combination in combinations(range(input_size), n):
            template = [False] * input_size
            for index in combination:
                template[index] = True
            yield template

    def tuples_covered(test_case, n, start=0, sublist=None):
        if n > len(test_case):
            raise ValueError("n cannot be greater than size of the test case")
        
        def gen_sublists(arr, n, start=0, sublist=None):
            if sublist is None:
                sublist = [None] * len(arr)

            if n == 0:
                yield sublist[:]
            else:
                for i in range(start, len(arr)):
                    sublist[i] = arr[i]
                    yield from gen_sublists(arr, n - 1, i + 1, sublist)
                    sublist[i] = None
        result = list(gen_sublists(test_case, n))
        return [tup for tup in result if tup.count(None) == len(tup) - n]
        
        
    def tuples_from_template(input_list, template):
        len_input_list = len(input_list)
        if len_input_list != len(template):
            raise ValueError("Input list and template must have the same length")

        selected_indices = [i for i, is_selected in enumerate(template) if is_selected]

        for combination in product(*[input_list[i] for i in selected_indices]):
            result = [None] * len_input_list
            for i, index in enumerate(selected_indices):
                result[index] = combination[i]
            yield result

    def tuples(input_list, n):
        if n > len(input_list):
            raise ValueError("n cannot be greater than the length of the input list")

        for template in tuple_template(n, len(input_list)):
            yield from tuples_from_template(input_list, template)

    tuples_to_cover = [tuple for tuple in tuples(input_list, n) if solver(tuple)]

    def tuple_score(candidate):
        if not solver(candidate):
            return -1
        else:
            covered_tuples = tuples_covered(candidate, n)
            score = len([x for x in covered_tuples if x in tuples_to_cover]) 
            return score
    
    while len(tuples_to_cover) > 0:
        for tuple_to_cover in tuples_to_cover:
            indices = [i for i, x in enumerate(tuple_to_cover) if x is None]
            random.shuffle(indices)
            
            constructed_test_case = tuple_to_cover.copy()
            for i in indices:
                best_candidate, best_score = None, -1
                for value in input_list[i]:
                    candidate = constructed_test_case.copy()
                    candidate[i] = value                
                    score = tuple_score(candidate)                    
                    if score > best_score:
                        best_candidate = candidate
                        best_score = tuple_score(candidate)
                        
                constructed_test_case = best_candidate
                tuples_to_cover[:] = [x for x in tuples_to_cover if x not in tuples_covered(constructed_test_case, n)]
            assigner(constructed_test_case)
            yield constructed_test_case

if __name__ == '__main__':
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print('Usage: python ecr_feed <input_file> [<output_file>]')
        sys.exit(1)
        
    input_file = sys.argv[1]
    if len(sys.argv) == 3:
        output_file = sys.argv[2]
    else:
        output_file = None
    
    model = Model(input_file)
    function = model.functions[0]
    params, choices = function.get_generator_input()

    print(','.join(params))
    for test in nwise(choices, 2, lambda x: True, lambda x: None):
        print(','.join(test))
    
    
